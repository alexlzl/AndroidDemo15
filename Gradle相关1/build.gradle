apply plugin: 'com.android.application'

android {
    compileSdkVersion 26



    defaultConfig {
        applicationId "com.example.myapplication"
        minSdkVersion 15
        targetSdkVersion 26
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        debug {

        }
    }
    /**
     * 调用Project的task()方法创建Task,在使用Gradle时，
     * 创建Task最常见的方式便是：这里的“<<”表示追加的意思，即向hello中加入执行过程。
     * 我们还可以使用doLast来达到同样的效果：
     */
    task helloWorld << {
        println "创建TASK的方式1===="
    }

    task hello2 {
        doLast {
            println '创建TASK的方式2===='
        }
    }
    /**
     * 另外，如果需要向Task的最前面加入执行过程，我们可以使用doFirst：
     */
    task hello3 {
        doFirst {
            println 'hello3'
        }
    }

    task testTask << {
        println("测试自定义task====")
    }

    task copyFile(type: Copy) {
        println("测试task复制============")
        from 'xml'
        into 'destination'
    }

    /**
     * Task之间是可以存在依赖关系，比如TaskA依赖TaskB，那么在执行TaskA时，Gradle会先执行TaskB，再执行TaskA
     */
    task taskA(dependsOn: copyFile) {
        println("测试task依赖============")
    }

    /**
     * 我们自定义的3个Task都位于TaskContainer中，Project中的tasks属性即表示该TaskContainer。为此，我们可以新建一个Task来显示这些信息：
     */
    task showTasks {
        println tasks.class
        println tasks.size()
    }
    /**
     * 通过TaskContainer的create()方法创建Task
     在上文中我们讲到，通过task()方法创建的Task都被存放在了TaskContainer中，
     而Project又维护了一个TaskContainer类型的属性tasks，那么我们完全可以直接向TaskContainer里面添加Task。
     查查TaskContainer的API文档可以发现，TaskContainer向我们提供了大量重载的create()方法用于添加Task。
     */
    tasks.create(name: 'hello4') << {
        println 'hello4'
    }

    /**
     * 　一个Task除了执行操作之外，还可以包含多个Property，其中有Gradle为每个Task默认定义的Property，
     * 比如description，logger等。另外，每一个特定的Task类型还可以含有特定的Property，比如Copy的from和to等。
     * 当然，我们还可以动态地向Task中加入额外的Property。在执行一个Task之前，我们通常都需要先设定Property的值，
     * Gradle提供了多种方法设置Task的Property值。
     */
    task hello7 << {
        description = "this is hello7"
        println description
    }
    /**
     * 我们还可以通过闭包的方式来配置一个已有的Task：
     *
     * 需要注意的是，对hello8的description设置发生在创建该Task之后，在执行“gradle hello8”时，命令行依然可以打印出正确的“this is hello8”，
     * 这是因为Gradle在执行Task时分为两个阶段，首先是配置阶段，然后才是实际执行阶段。
     * 所以在执行hello8之前，Gradle会扫描整个build.gradle文档，将hello8的description设置为“this is hello8”，
     * 然后执行hello8，此时hello8的description已经包含了设置后的值
     */
    task hello8 << {
        println description
    }

    hello8 {
        description = "this is hello8"
    }

    /**
     * 　我们还可以通过调用Task的configure()方法完成Property的设置：
     */
    task hello9 << {
        println description
    }

    hello9.configure {
        description = "this is hello9"
    }

}

/**
 * 如果我们将Gradle的Task看作一个黑盒子， 那么我们便可以抽象出输入和输出的概念，一个Task对输入进行操作，然后产生输出。
 * 比如，在使用java插件编译源代码时，输入即为Java源文件，输出则为class文件。
 * 如果多次执行一个Task时的输入和输出是一样的，那么我们便可以认为这样的Task是没有必要重复执行的。此时，反复执行相同的Task是冗余的，并且是耗时的。
 * 为了解决这样的问题，Gradle引入了增量式构建的概念。在增量式构建中，我们为每个Task定义输入（inputs）和输入（outputs），
 * 如果在执行一个Task时，如果它的输入和输出与前一次执行时没有发生变化，那么Gradle便会认为该Task是最新的（UP-TO-DATE），
 * 因此Gradle将不予执行。一个Task的inputs和outputs可以是一个或多个文件，可以是文件夹，还可以是Project的某个Property，甚至可以是某个闭包所定义的条件。
 * 每个Task都拥有inputs和outputs属性，他们的类型分别为TaskInputs和TaskOutputs。在下面的例子中，我们展示了这么一种场景：
 * 名为combineFileContent的Task从sourceDir目录中读取所有的文件，然后将每个文件的内容合并到destination.txt文件中。让我们先来看看没有定义Task输入和输出的情况：
 */
//task combineFileContentNonIncremental {
//    def sources = fileTree('sourceDir')
//
//    def destination = file('destination.txt')
//
//    doLast {
//        destination.withPrintWriter { writer ->
//            sources.each {source ->
//                writer.println source.text
//            }
//        }
//    }
//}

/**
 * 多次执行“gradle combineFileContentNonIncremental”时，整个Task都会反复执行，即便在第一次执行后我们已经得到了所需的结果。
 * 如果该combineFileContentNonIncremental是一个繁重的Task，那么多次重复执行势必造成没必要的时间耗费。
 * 这时，我们可以将sources声明为该Task的inputs，而将destination声明为outputs，重新创建一个Task如下：
 */
task combineFileContentIncremental {
    def sources = fileTree('sourceDir')
    def destination = file('destination.txt')


    inputs.dir sources

    outputs.file destination

    doLast {
        destination.withPrintWriter {
            writer ->
                sources.each {
                    source ->
                        writer.println source.text
                }
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    implementation 'com.android.support:appcompat-v7:26.1.0'
    implementation 'com.android.support.constraint:constraint-layout:1.0.2'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.1'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
}
